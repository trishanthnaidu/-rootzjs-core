"use strict";

Object.defineProperty(exports, "__esModule", {
        value: true
});
exports.createContract = exports.createNode = exports.Node = exports.validateActions = exports.setNodeState = exports.updateNodeState = void 0;

var _react = _interopRequireDefault(require("react"));

var _main = require("./main");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const updateNodeState = (nodeId, state) => {
        setNodeState(nodeId, state);
        (0, _main.requestUpdate)(nodeId);
};

exports.updateNodeState = updateNodeState;

const setNodeState = (nodeId, state) => {
        if (!_main.store.hasOwnProperty(nodeId)) {
                _main.store[nodeId] = {
                        "state": {},
                        "leafs": {},
                        "contract": []
                };
        }

        _main.store[nodeId]["state"] = (0, _main.setImmutableObject)(_main.store[nodeId]["state"], state);
};

exports.setNodeState = setNodeState;

const validateActions = (actions, id) => {
        if (typeof actions !== "function") {
                console.log(_main.ERROR.ACTIONS_ARE_NOT_FUNCTION(id), consoleColorCode.error.brand, consoleColorCode.common.title, consoleColorCode.common.context);
                throw new Error();
        }
};

exports.validateActions = validateActions;

const validateContract = (contract, id) => {
        if (contract[0] && !contract[0].hasOwnProperty("__type")) {
                console.log(_main.ERROR.INVALID_CONTRACT_TYPE(id), consoleColorCode.error.brand, consoleColorCode.common.title, consoleColorCode.common.context);
                throw new Error();
        }
};

const addMappingsForContract = (nodeId, contract) => {
        const mappings = contract[0].__mappings;
        const nodeIds = Object.values(mappings);
        _main.store[nodeId]["contract"] = (0, _main.setImmutableObject)(_main.store[nodeId]["contract"], nodeIds);
};

const getNodeState = nodeId => {
        let emptyState = {};
        return (0, _main.setImmutableObject)(emptyState, _main.store[nodeId]["state"]);
};

const validateNodeId = nodeId => {
        // check if the leafId already exists
        if (_main.store.hasOwnProperty(nodeId)) {
                console.log(_main.ERROR.NODE_NAME_ALREADY_EXISTS(nodeId), consoleColorCode.error.brand, consoleColorCode.common.title, consoleColorCode.common.context);
                throw new Error();
        }
};

const createNode = ({
        id,
        updateIf,
        Component,
        state = {},
        actions = [[], []]
}) => {
        var _temp;

        // create a state handler variable for refreshing the state
        const stateHandlerVariable = {
                __rootzStateHandlerVariable: 0
        }; // Store the initial State in the applicaton Store

        setNodeState(id, state); // sets the handler variable in the Store

        (0, _main.setHandlerVariable)(id, stateHandlerVariable);
        return {
                [id]: class extends _react.default.PureComponent {
                        constructor(props) {
                                super(props);

                                _defineProperty(this, "shouldComponentUpdate", updateIf);

                                this.state = stateHandlerVariable;
                                this.derivedActions = {};
                                const selfActions = actions[0] || [];
                                const contract = actions[1] || [];
                                selfActions.forEach(func => {
                                        validateActions(func, id);

                                        this.derivedActions[func.name] = (...props) => {
                                                const derivedState = func(...props);
                                                updateNodeState(id, derivedState);
                                        };
                                });

                                if (contract.length > 0) {
                                        validateContract(contract);
                                        addMappingsForContract(id, contract);
                                        this.derivedActions = _objectSpread(_objectSpread({}, this.derivedActions), contract[0]);
                                } // setting the handler


                                _main.setHandler.call(this, id, this.setState);
                        }

                        render() {
                                if (!_main.scopeVariables.nodes.hasOwnProperty(id)) {
                                        let contractObj = {};
                                        const contract = actions[1] || [];

                                        if (contract.length > 0) {
                                                contract[0].__mappings.forEach(x => {
                                                        contractObj[x.id] = [x.action];
                                                });
                                        }

                                        _main.scopeVariables.nodes[id] = {
                                                scope: {},
                                                actions: {}
                                        };
                                        _main.scopeVariables.nodes[id]["scope"] = (0, _main.setImmutableObject)(_main.scopeVariables.nodes[id]["scope"], this);
                                        _main.scopeVariables.nodes[id]["actions"] = (0, _main.setImmutableObject)(_main.scopeVariables.nodes[id]["actions"], _objectSpread({
                                                [id]: actions[0].map(x => x.name)
                                        }, contractObj));
                                } // fetches the latest state everytime the package is called


                                const state = getNodeState(id);
                                const context = (0, _main.getContext)();
                                return /*#__PURE__*/_react.default.createElement(Component, {
                                        state: state,
                                        context: context,
                                        props: this.props,
                                        actions: this.derivedActions
                                });
                        }

                }
        }[id];
};

exports.createNode = createNode;

const createContract = actionsMappings => {
        const keys = Object.keys(actionsMappings);
        const keyNameMap = Object.values(actionsMappings).map((x, i) => ({
                "id": keys[i],
                "action": x.name
        }));
        let contractActions = {
                __type: "contract",
                __mappings: keyNameMap
        };
        keys.forEach(id => {
                const func = actionsMappings[id];
                validateActions(func, id);

                contractActions[func.name] = (...props) => {
                        const derivedState = func(...props);
                        updateNodeState(id, derivedState);
                };
        });
        return [contractActions];
};

exports.createContract = createContract;
const Node = {
        setState: (id, state) => updateNodeState(id, state),
        getState: id => getNodeState(id)
};
exports.Node = Node;